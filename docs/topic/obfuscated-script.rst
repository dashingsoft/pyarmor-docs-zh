.. highlight:: bash

==============================
Insight Into Obfuscated Script
==============================

深入了解加密脚本

如何运行 PyArmor 的加密脚本
===========================

本文档适用于下列用户

* 默认选项无法满足加密脚本的性能或者安全方面的需求
* 加密脚本无法正常运行

阅读本文档需要一定的 Python 基础，了解 Shell 脚本，环境变量等相关知识。

PyArmor 加密后的脚本输出的是同名的 `.py` 文件和扩展模块 `pyarmor_runtime`。例如
foo.py 加密后在输出目录 dist 会创建下面的两个文件::

    dist/
        foo.py
        pyarmor_runtime.so

它们和普通 Python 模块，可以被 Python 解释器调用执行，这也是 PyArmor 的一个加密
特点，可以使用加密后的脚本无缝替换原来的脚本。

使用加密脚本完全和使用普通的 Python 脚本一样，例如，使用解释器直接运行::

    python dist/foo.py

使用文本编辑器打开这个脚本，它的内容一般如下::

    from pyarmor_runtime import __pyarmor__
    __pyarmor__(__name__, __file__, b'\x28\x83....', 1)

可以看到第一条语句就是导入扩展模块 `pyarmor_runtime`，它就是和加密脚本在相同目录
下的文件 `pyarmor_runtime.so` 。扩展模块 `pyarmor_runtime` 不是必须和加密脚本放
在一起，只要它存在于 Python 搜索模块的任何路径，能被 Python 导入进来，加密脚本就
可以正常使用。

如果运行加密脚本的时候提示模块 `pyarmor_runtime` 无法找到，首先要能找到扩展模块
文件，然后在扩展模块文件所在的目录直接使用 Python 解释器导入这个模块::

    cd dist/
    python
    >>> import pyarmor_runtime

如果不能正常导入，说明文件格式不正确，不适用于当前平台和 Python 版本。

扩展模块是二进制的动态库，有些文本脚本可以执行的环境，因为扩展模块而无法使用。这
种情况只要了解扩展模块的相关知识，设置运行环境允许加载扩展模块，都可以正常运行加
密脚本。判断运行环境是否允许加载扩展模块的方法是把任何一个系统扩展模块拷贝到当前
目录，看看能否导入。

在导入扩展模块 `pyarmor_runtime` 之前，所有的事情都是 Python 解释器的功能，和
PyArmor 和加密脚本没有关系。解决这里出现的问题需要的就是学习 Python 相关的知识，
特别是 Python 是如何根据模块名称去搜索和装载模块和扩展模块的。

扩展模块 `pyarmor_runtime` 第一次被导入的时候，会进行一些初始化工作。

1. 扩展模块初始化
-----------------

`pyarmor_runtime` 模块的初始化工作主要包括

* 检查运行许可证

2. 装载加密模块
---------------

相关选项 --restirct --obf-mod

检查运行许可证
检查加密脚本是否被修改
检查调用者是否也是加密脚本

解密模块代码
装载真正的模块代码

3. 装载加密函数
---------------

相关选项 --obf-code

检查调用者是否加密

解密函数
调用原来的函数代码
重新加密函数

如何设置加密脚本的有效期

如何限制加密脚本运行的设备
如何定制错误信息
如何生成支持多平台的加密脚本
如何生成支持多个 Python 版本的加密脚本

如何生成速度最快的加密脚本

如何生成安全性最高的加密脚本
----------------------------

* 使用选项
* 重构脚本，例如 BCC 模式，把不支持 BCC 模式的函数进行拆分

如何定制加密脚本的行为
----------------------

应用场景

    在运行加密脚本之前，进行一些初始化，例如把定制的许可证进行解码，恢复成为 Pyarmor 可以识别的方式
    周期性的检查是否有调试器


使用方法

1. 生成许可证的时候指定运行钩子，可以是一个 Python 函数，在 BCC 模式下面，也可以是一个 c 函数
2. 设定运行的时机
   * 装载加密脚本之前，导入 pyarmor_runtime 的时候，只能运行一次
   * 每一次装载加密模块
   * 每一次运行加密函数
   * 定时运行

典型应用一，保护许可证

1. 使用 pyarmor generate key 生成许可证
2. 对生成的许可证进行编码，这样就无法被用来启动加密脚本
3. 加密脚本设置运行钩子，Python 函数，用来解码许可证
4. 设置运行时机为启动加密脚本


   典型应用一，检查是否有调试器，需要使用 BCC 模式加密

1. 首先写一个 c 函数，可以检查是否有调试器
2. 加密脚本设置运行钩子为 c 函数，传入源代码即可
3. 设置运行时机是每 30 秒执行一次

在加密脚本运行之后，这个函数每 30 秒就会被调用一次

.. include:: ../_common_definitions.txt
